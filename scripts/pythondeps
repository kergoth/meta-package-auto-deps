#!/usr/bin/env python
#
# Determine dependencies of python scripts or available python modules in a search path.
#
# Given the -d argument and a filename/filenames, returns the modules imported by those files.
# Given the -d argument and a directory/directories, recurses to find all
# python packages and modules, returns the modules imported by these. In this
# mode, each package gets imported, so beware of packages whose import causes
# side effects.
# Given the -p argument and a path or paths, scans that path for available python modules/packages.

import argparse
import ast
import imp
import logging
import os.path
import sys


logger = logging.getLogger('pythondeps')

suffixes = []
for triple in imp.get_suffixes():
    suffixes.append(triple[0])


class PythonDepError(Exception):
    pass


class DependError(PythonDepError):
    def __init__(self, path, error):
        self.path = path
        self.error = error
        PythonDepError.__init__(self, error)

    def __str__(self):
        return "Failure determining dependencies of {}: {}".format(self.path, self.error)


class And(list):
    def __repr__(self):
        return 'And([{0}])'.format(', '.join(repr(s) for s in self))

    def __str__(self):
        return " & ".join(str(s) for s in self if s)


class Or(list):
    def __repr__(self):
        return 'Or([{0}])'.format(', '.join(repr(s) for s in self))

    def __str__(self):
        return " | ".join(str(s) for s in self if s)


def get_importfrom_name(node, package_context):
    if node.level == 0:
        return [node.module]
    elif not provide:
        raise DependError("Error: ImportFrom non-zero level outside of a package: {0}".format((node.module, [a.name for a in node.names], node.level)), path)
    elif level > len(provide_elements):
        raise DependError("Error: ImportFrom level exceeds package depth: {0}".format((node.module, [a.name for a in node.names], node.level)), path)
    else:
        context = '.'.join(package_context[:-node.level])
        if module:
            if context:
                return [context + '.' + module]
            else:
                return [module]

def name_tree(tree, package_context=None):
    for i, node in enumerate(tree):
        if isinstance(node, (And, Or)):
            name_tree(node, package_context)
        elif isinstance(node, ast.Import):
            tree[i] = [alias.name for alias in node.names]
        elif isinstance(node, ast.ImportFrom):
            tree[i] = And(get_importfrom_name(node, package_context))
        else:
            raise DependError("Error: can't determine module name for {0}".format(node))


class ImportVisitor(ast.NodeVisitor):
    def __init__(self):
        self.imports = []
        self.import_options = Or()

    def visit_Import(self, node):
        self.imports.append(node)

    def visit_ImportFrom(self, node):
        self.imports.append(node)

    def visit_TryExcept(self, node):
        options = self.get_import_options(node)
        if options is None:
            self.generic_visit(node)
        else:
            self.import_options.extend(options)

    def get_import_options(self, node):
        options = Or()
        if not all(isinstance(s, (ast.Import, ast.ImportFrom)) for s in node.body):
            # unsupported try/except block
            return

        nodes_all = ImportVisitor()
        for s in node.body:
            nodes_all.visit(s)
        options.append(And(nodes_all.imports))

        if (node.orelse or len(node.handlers) != 1
                or node.handlers[0].type.id != 'ImportError'):
            # unsupported try/except block
            return

        exc = node.handlers[0].body
        if not all(isinstance(s, (ast.Import, ast.ImportFrom)) for s in exc):
            if len(exc) != 1 or not isinstance(exc[0], ast.TryExcept):
                # unsupported try/except block
                return

        nodes_exc = ImportVisitor()
        for s in exc:
            nodes_exc.visit(s)
        options.append(And(nodes_exc.imports))
        if nodes_exc.import_options:
            options.append(Or(nodes_exc.import_options))
        return options


def get_provides(path):
    if not path.endswith('/'):
        path = path + '/'

    provides = set()
    for root, dirnames, filenames in os.walk(path):
        full_root = root
        root = root[len(path):]
        if root and '__init__.py' not in filenames:
            dirnames[:] = []
            continue

        if root:
            provides.add((root.replace('/', '.'), full_root))

        for filename in filenames:
            for suffix in suffixes:
                if filename.endswith(suffix):
                    base = filename[:-len(suffix)]
                    if base != '__init__':
                        fullpath = os.path.join(root, base)
                        provides.add((fullpath.replace('/', '.'), os.path.join(full_root, filename)))

    return provides


def get_code_depends(code_string, path=None, provide=None, ispkg=False):
    try:
        code = ast.parse(code_string, path)
    except TypeError as exc:
        raise DependError(path, exc)
    except SyntaxError as exc:
        raise DependError(path, exc)

    visitor = ImportVisitor()
    visitor.visit(code)
    for builtin_module in sys.builtin_module_names:
        if builtin_module in visitor.imports:
            visitor.imports.remove(builtin_module)

    name_tree(visitor.imports)
    for module in visitor.imports:
        yield module, path

    if provide:
        provide_elements = provide.split('.')
        if ispkg:
            provide_elements.append("__self__")
    else:
        provide_elements = None

    if visitor.import_options:
        name_tree(visitor.import_options, provide_elements)
        yield str(visitor.import_options), path


def get_file_depends(path):
    try:
        code_string = open(path, 'r').read()
    except (OSError, IOError) as exc:
        raise DependError(path, exc)

    return get_code_depends(code_string, path)


def get_depends_recursive(directory):
    import pkgutil
    directory = os.path.realpath(directory)

    provides = dict((v, k) for k, v in get_provides(directory))
    sys.path[0:0] = [directory]
    for imp, name, ispkg in pkgutil.walk_packages([directory]):
        loader = imp.find_module(name)
        filename = loader.get_filename()
        if not filename.startswith(directory + '/'):
            raise DependError(directory, "Package walking encountered path `{}`, outside the tree".format(filename))

        if not filename.endswith('.py'):
            continue

        if ispkg:
            provide = provides.get(os.path.dirname(filename))
        else:
            provide = provides.get(filename)

        source = loader.get_source()
        depends = get_code_depends(source, filename, provide, ispkg)
        for depend, by in depends:
            yield depend, by


def get_depends(path):
    if os.path.isdir(path):
        return get_depends_recursive(path)
    else:
        return get_file_depends(path)


def main():
    logging.basicConfig()

    parser = argparse.ArgumentParser(description='Determine dependencies and provided packages for python scripts/modules')
    parser.add_argument('path', nargs='+', help='full path to content to be processed')
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-p', '--provides', action='store_true',
                       help='given a path, display the provided python modules')
    group.add_argument('-d', '--depends', action='store_true',
                       help='given a filename, display the imported python modules')

    args = parser.parse_args()
    if args.provides:
        modules = set()
        for path in args.path:
            for provide, filename in get_provides(path):
                modules.add(provide)

        for module in sorted(modules):
            print(module)
    elif args.depends:
        for path in args.path:
            try:
                modules = get_depends(path)
            except PythonDepError as exc:
                logger.error(str(exc))
                sys.exit(1)

            for module, imp_by in modules:
                print(module)
    else:
        parser.print_help()
        sys.exit(2)


if __name__ == '__main__':
    main()
